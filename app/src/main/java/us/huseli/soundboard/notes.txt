    private fun extractEncoded(priming: Boolean) = runBlocking {
        /**
         * When priming: Ideally extract exactly `bufferSize` bytes of audio data. If there is some
         * overshoot, put it in `overrunSampleData`. Try to accomplish this by running codec input
         * and output "serially", i.e. only get input buffer when there has been a successful
         * output buffer get just before (except for the first iteration, of course).
         */
        var inputEos = false
        var outputRetries = 0
        var outputStopped = false
        var doExtraction = true
        var totalSize = primedSize
        
        try {
            while (!outputStopped && isActive) {
                if (!inputEos && doExtraction) inputEos = processInputBuffer()
                val (outputResult, sampleSize, buffer) = processOutputBuffer(totalSize)
                if (buffer != null) writeAudioTrack(buffer)
                totalSize += sampleSize
                when (outputResult) {
                    ProcessOutputResult.SUCCESS -> {
                        outputRetries = 0
                        // We don't _know_ that the next buffer will be of the same size as the current
                        // one, but it's an educated guess that's good enough:
                        if (priming) doExtraction = totalSize + sampleSize < bufferSize
                        outputStopped = false
                    }
                    ProcessOutputResult.EOS -> {
                        if (priming) doExtraction = false
                        outputStopped = true
                    }
                    else -> {
                        if (priming) doExtraction = false
                        outputStopped = outputRetries++ >= 5
                    }
                }
                if (BuildConfig.DEBUG) Log.d(
                    LOG_TAG,
                    "extractEncoded: outputResult=$outputResult, outputRetries=$outputRetries, outputStopped=$outputStopped, doExtraction=$doExtraction, state=$state, priming=$priming, sound=$sound"
                )
            }
            if (BuildConfig.DEBUG) Log.d(
                LOG_TAG,
                "**** extractEncoded: Extract finished: totalSize=$totalSize, totalSize before extract=$primedSize, added=${totalSize - primedSize}, state=$state, priming=$priming, sound=$sound"
            )
            if (priming) primedSize = totalSize
        } finally {
            if (BuildConfig.DEBUG) Log.d(LOG_TAG, "extractEncoded: cancelled")
        }
    }



soundplayer state READY
AudioFile@12753







val collection = MediaStore.Audio.Media.getContentUri(MediaStore.VOLUME_EXTERNAL)
val projection = arrayOf(MediaStore.Audio.Media._ID, MediaStore.Audio.Media.DISPLAY_NAME, MediaStore.Audio.Media.TITLE, MediaStore.Audio.Media.DURATION, MediaStore.Audio.Media.MIME_TYPE)
val selection = "${MediaStore.Audio.Media.DURATION} <= ?"
val selectionArgs = arrayOf("3000")
val query = contentResolver.query(collection, projection, selection, selectionArgs, null)
val audioList = mutableListOf<Array<String>>()
query?.use { cursor ->
    val idCol = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media._ID)
    val nameCol = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DISPLAY_NAME)
    val titleCol = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.TITLE)
    val durationCol = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DURATION)
    val mimeCol = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.MIME_TYPE)
    while (cursor.moveToNext()) {
        audioList.add(arrayOf(cursor.getLong(idCol).toString(), cursor.getString(nameCol), cursor.getString(titleCol), cursor.getInt(durationCol).toString(), cursor.getString(mimeCol)))
    }
}


SPEKULATIONER
Vad händer när jag flyttar ett ljud till annan kategori?
1. Jag kör startDragAndDrop() på en View, som är SoundAdapter.binding.soundContainer, dvs en
    ConstraintLayout från item_sound.xml
2. SoundDragListener2.onDragLocation() kör callback.insertOrMoveSound, där callback är den nya
    kategorins SoundAdapter
3. SoundAdapter.insertOrMoveSound() kör categoryViewModel.insertSound(...)
4. CategoryViewModel.insertSound() kör updateSounds() med den nya kategorins uppdaterade Sound-
    lista (inkl. det flyttade ljudet)
5. CategoryViewModel.updateSounds() kör soundRepository.update() med denna lista
6. SoundRepository.update() kör soundDao.update() med samma lista
7. SoundDao.update() uppdaterar SQL-rad för varje ljud i listan
8. CategoryViewModel.sounds live-uppdateras med nya listor via soundRepository.getByCategory()
    -- för alla kategorier. Dvs även den gamla kategorin får ny lista, utan det flyttade ljudet.
9. CategoryAdapter.ViewHolder för den _gamla_ kategorin skickar uppdaterad ljudlista till
    sin soundAdapter.submitList()
10. SoundAdapter.submitList() > ListAdapter.submitList() > AsyncListDiffer.submitList()
11. AsyncListDiffer.submitList() kör listan via DiffUtil med SoundAdapter.DiffCallback, oerhört
    snårigt vad som sker sedan
12. Men TROLIGEN körs SoundAdapter.notifyItemRemoved d.v.s.
    RecyclerView.Adapter.notifyItemRemoved(ljudets f.d. position), som kör
    RecyclerView.AdapterDataObservable().notifyItemRangeRemoved(position, 1).
13. Därifrån körs onItemRangeRemoved(positionStart, itemCount) på alla AdapterDataObservers, vilka
    de nu är, men troligen är de RecyclerView.RecyclerViewDataObserver
14. TROLIGEN mynnar detta ut i att ljudets gamla ViewHolder + View tas bort på ngt vis
15. TROLIGEN körs RecyclerView.RecyclerViewDataObserver.onItemRangeRemoved(position, 1), som kör
    AdapterHelper.onItemRangeRemoved(position, 1)
16. Om ovanstående stämmer, är vi nu i ett läge där View från (1) är borttagen från skärmen (typ),
    men dess startDragAndDrop() körs fortfarande ... kan detta vara problemet?

ÅTGÄRDER OM SPEKULATIONERNA STÄMMER
a)  Vänta med att ta bort ljud från gamla SoundAdaptern tills drag är slutförd. Detta innebär att
    vi måste ställa om så att SoundAdapter.notifyItem* inte automatiskt uppdaterar DB i varje
    läge, utan om drag är pågående så uppskjuts de operationerna, men views uppdateras ändå.
    Förhoppningsvis är det så enkelt att man, under pågående drag, kan köra notifyItem* direkt
    bara? Och inte insertOrMoveSound() eller något annat som kör submitList().
        Eller NEJ, det är det ju inte :-////// -- notifyItem* förlitar sig fortfarande på
    currentList, som handhas av ListAdapter. Så måste hitta något sätt att uppdatera currentList
    utan att det förs vidare till databasen.
        currentList är inte mutable utan är bara tänkt att uppdateras via submitList(). Men
    ListAdapter.submitList() har i sig inget med databasen att göra. Så det borde funka att bara
    köra submitList() med den lista man för tillfället vill visa, utan att DB ändras alls.
        Eller NEJ igen. Kör man submitList() så uppdateras views enligt denna lista, skit samma
    om det har gått via DB eller ej. Poängen är att ursprungs-View:n från (1) troligen måste vara
    kvar tills drag är avslutad helt enkelt.
        Kanske vi inte alls får röra original-View tills drag är avslutad? Dvs denna adapter-
    position får inte flyttas eller något. Dock alla andra.
b)  Gör ngn slug manöver i stil med att, vid ACTION_DRAG_ENTERED, avsluta nuvarande drag och starta
    en ny (implicerar iofs (a), så den behöver göras oavsett)
c)  Skit opp arslet så det är stort som fan
