Only add to undo queue when something has actually changed


Android has a limit of 128 persisted URI grants! https://stackoverflow.com/questions/30802971/android-max-number-of-persistable-uri-permission-granted-to-an-app-is-limited-to?rq=1
So after 128 sounds have been added, any additional X added sounds will mean that the first added
X number of sounds will no longer have persisted URI grants.
Apparently, in Android 11 it's changed to 512: https://issuetracker.google.com/issues/149315521#comment7
But it has to be addressed somehow.
Option 1: Don't request persisted grant when number of sounds >= 128, warn user about it
Option 2: Copy all added sounds to app storage
Option 3: Use ACTION_OPEN_DOCUMENT_TREE; needs to be researched and only works with API >= 21:
    https://developer.android.com/reference/android/content/Intent#ACTION_OPEN_DOCUMENT_TREE
Went for option 2!


Refactor so add/edit multiple sounds name view show number of sounds selected


Show some progress indicator while loading sounds (not only on app init but also reorder etc)


Change duplicate add fragment so buttons are the same colour


Can't seem to undo adding a sound, or deleting it


Also enable undo for category changes


Can the responsiveness (time from soundcard press to sound playing) be improved further?


Check for stuff that could be done in worker threads


Lots of errors on release version. Memory leaks?
Especially when starting many mediaplayers simultaneously.
(Does not seem to be eating a bunch of cpu or memory though)


When collapsing last category, its header disappears from view until you scroll, then reappears
CategoryAdapter.onViewDetachedFromWindow() is run for that holder and it's hidden. Why?


On ordering enabled: scroll with 2 fingers?


Clean up Log calls


After altering a category, play icon & volumebar on sounds dont work? (Cannot recreate?)


In some instance, when creating categories and moving sounds around, an empty category was
populated with another category's sounds (How to recreate?)


Run release() on MediaPlayer objects at some point (research activity/app lifecycle to decide when)
Or just let GC take care of it?


Check for usages of adapterPosition/layoutPosition and correct according to
https://developer.android.com/reference/kotlin/androidx/recyclerview/widget/RecyclerView#positions-in-recyclerview:


Problem: UI gets laggy on first scroll because Sound recyclerviews that are at first not visible
don't get populated until they are. Their sounds are fetched and sent via submitList(), but nothing
more is done until the recyclerview enters the window.
Solution #1: Do as much work as possible (mainly getPlayer()) before this happens
Solution #2: Fuck around with RecyclerView.LayoutManager.LayoutPrefetchRegistry
    (https://developer.android.com/reference/kotlin/androidx/recyclerview/widget/RecyclerView.LayoutManager#collectinitialprefetchpositions)
    If API level >= 21 (L+), tryGetViewHolderForPositionByDeadline() scans holder.itemView for
    nested recyclerviews after creating holder via adapter.createViewHolder(). It does so via
    RecyclerView.findNestedRecyclerView() and then adds it to holder.mNestedRecyclerView.
    GapWorker.prefetchInnerRecyclerViewWithDeadline() is run with that nested RecyclerView as
    argument.
    Seems like there is an issue here somewhere though? https://stackoverflow.com/questions/54150680/nested-recyclerview-prefetch-not-working-on-initial-scroll-only

2020-12-03: Trying out #2
2020-12-03: Trying out #1 also


If trying to add sounds without permission (like after a reinstall), MediaPlayer.prepare() throws
IOException. Maybe catch that and alert the user that they could make some menu choice to
re-init the failed sound URIs?
Perhaps use some 'failedSounds' list in appViewModel or something. But where to populate it?
SoundPlayer.setup() would be the obvious choise but that class doesn't know about Sound, only
Uri and volume.
setup() is called by SoundViewModel.getPlayer(), which DOES know about Sound, so maybe here?
But then we have to re-throw the IOException to it.
Also, it's a viewmodel and does not, and should not, know about other viewmodels.
getPlayer is in turn called by SoundAdapter.SoundViewHolder.bind(), so maybe here?
But we can't throw the exception all the way here. Maybe set some 'noPermission' bool on
SoundPlayer instead? And check it here, and if true add sound to 'failedSounds'.

OK, failedSounds and noPermission is implemented, now:
- Show alert
- Add menu item "re-add failed sounds"
- Implement that functionality
- Remove test data from SoundViewHolder.bind and Sound.constructor


Make sure old adapters & viewholders are garbage collected on config change/rotate, they don't seem
to be doing so automatically


Write tests :-//////////////


Trash CategoryListFragment, put it all in MainActivity?

######## PROBABLY NOT #########

Try setting AudioAttributes: https://developer.android.com/reference/kotlin/android/media/AudioAttributes
- FLAG_LOW_LATENCY (Deprecated: Use AudioTrack.Builder#setPerformanceMode(int) with AudioTrack#PERFORMANCE_MODE_LOW_LATENCY to control performance.)
- USAGE_MEDIA
Comment: This is probably WAY too cumbersome to be worth it.
See: https://mindtherobot.com/blog/580/android-audio-play-a-wav-file-on-an-audiotrack/

Share sounds from other apps to this one -- seems like it's not possible to do this and get
persistable permissions to the URI? :(
